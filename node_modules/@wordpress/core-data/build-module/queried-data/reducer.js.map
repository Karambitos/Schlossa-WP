{"version":3,"sources":["@wordpress/core-data/src/queried-data/reducer.js"],"names":["map","flowRight","combineReducers","conservativeMapItem","ifMatchingAction","replaceAction","onSubKey","DEFAULT_ENTITY_KEY","getQueryParts","getMergedItemIds","itemIds","nextItemIds","page","perPage","receivedAllIds","nextItemIdsStartIndex","size","Math","max","length","mergedItemIds","Array","i","isInNextItemsRange","items","state","action","type","key","reduce","accumulator","value","itemId","queries","query"],"mappings":";;;;;;AAAA;;;AAGA,SAASA,GAAT,EAAcC,SAAd,QAA+B,QAA/B;AAEA;;;;AAGA,SAASC,eAAT,QAAgC,iBAAhC;AAEA;;;;AAGA,SACCC,mBADD,EAECC,gBAFD,EAGCC,aAHD,EAICC,QAJD,QAKO,UALP;AAMA,SAASC,kBAAT,QAAmC,aAAnC;AACA,OAAOC,aAAP,MAA0B,mBAA1B;AAEA;;;;;;;;;;;;AAWA,OAAO,SAASC,gBAAT,CAA2BC,OAA3B,EAAoCC,WAApC,EAAiDC,IAAjD,EAAuDC,OAAvD,EAAiE;AACvE,MAAMC,cAAc,GAAGF,IAAI,KAAK,CAAT,IAAcC,OAAO,KAAK,CAAC,CAAlD;;AACA,MAAKC,cAAL,EAAsB;AACrB,WAAOH,WAAP;AACA;;AACD,MAAMI,qBAAqB,GAAG,CAAEH,IAAI,GAAG,CAAT,IAAeC,OAA7C,CALuE,CAOvE;AACA;;AACA,MAAMG,IAAI,GAAGC,IAAI,CAACC,GAAL,CACZR,OAAO,CAACS,MADI,EAEZJ,qBAAqB,GAAGJ,WAAW,CAACQ,MAFxB,CAAb,CATuE,CAcvE;;AACA,MAAMC,aAAa,GAAG,IAAIC,KAAJ,CAAWL,IAAX,CAAtB;;AAEA,OAAM,IAAIM,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGN,IAArB,EAA2BM,CAAC,EAA5B,EAAiC;AAChC;AACA,QAAMC,kBAAkB,GACvBD,CAAC,IAAIP,qBAAL,IACAO,CAAC,GAAGP,qBAAqB,GAAGJ,WAAW,CAACQ,MAFzC;AAIAC,IAAAA,aAAa,CAAEE,CAAF,CAAb,GAAqBC,kBAAkB,GACpCZ,WAAW,CAAEW,CAAC,GAAGP,qBAAN,CADyB,GAEpCL,OAAO,CAAEY,CAAF,CAFV;AAGA;;AAED,SAAOF,aAAP;AACA;AAED;;;;;;;;;;AASA,SAASI,KAAT,GAAqC;AAAA,MAArBC,KAAqB,uEAAb,EAAa;AAAA,MAATC,MAAS;;AACpC,UAASA,MAAM,CAACC,IAAhB;AACC,SAAK,eAAL;AACC,UAAMC,GAAG,GAAGF,MAAM,CAACE,GAAP,IAAcrB,kBAA1B;AACA,+BACIkB,KADJ,MAEIC,MAAM,CAACF,KAAP,CAAaK,MAAb,CAAqB,UAAEC,WAAF,EAAeC,KAAf,EAA0B;AACjD,YAAMC,MAAM,GAAGD,KAAK,CAAEH,GAAF,CAApB;AACAE,QAAAA,WAAW,CAAEE,MAAF,CAAX,GAAwB7B,mBAAmB,CAC1CsB,KAAK,CAAEO,MAAF,CADqC,EAE1CD,KAF0C,CAA3C;AAIA,eAAOD,WAAP;AACA,OAPE,EAOA,EAPA,CAFJ;AAHF;;AAgBA,SAAOL,KAAP;AACA;AAED;;;;;;;;;;;AASA,IAAMQ,OAAO,GAAGhC,SAAS,CAAE,CAC1B;AACA;AACAG,gBAAgB,CAAE,UAAEsB,MAAF;AAAA,SAAc,WAAWA,MAAzB;AAAA,CAAF,CAHU,EAK1B;AACArB,aAAa,CAAE,UAAEqB,MAAF,EAAc;AAC5B;AACA;AACA;AACA,MAAKA,MAAM,CAACQ,KAAZ,EAAoB;AACnB,6BACIR,MADJ,MAEIlB,aAAa,CAAEkB,MAAM,CAACQ,KAAT,CAFjB;AAIA;;AAED,SAAOR,MAAP;AACA,CAZY,CANa,EAoB1B;AACA;AACApB,QAAQ,CAAE,WAAF,CAtBkB,CAAF,CAAT,CAuBX,YAA4B;AAAA,MAA1BmB,KAA0B,uEAAlB,IAAkB;AAAA,MAAZC,MAAY;AAAA,MACxBC,IADwB,GAC0BD,MAD1B,CACxBC,IADwB;AAAA,MAClBf,IADkB,GAC0Bc,MAD1B,CAClBd,IADkB;AAAA,MACZC,OADY,GAC0Ba,MAD1B,CACZb,OADY;AAAA,oBAC0Ba,MAD1B,CACHE,GADG;AAAA,MACHA,GADG,4BACGrB,kBADH;;AAGhC,MAAKoB,IAAI,KAAK,eAAd,EAAgC;AAC/B,WAAOF,KAAP;AACA;;AAED,SAAOhB,gBAAgB,CACtBgB,KAAK,IAAI,EADa,EAEtBzB,GAAG,CAAE0B,MAAM,CAACF,KAAT,EAAgBI,GAAhB,CAFmB,EAGtBhB,IAHsB,EAItBC,OAJsB,CAAvB;AAMA,CApCe,CAAhB;AAsCA,eAAeX,eAAe,CAAE;AAC/BsB,EAAAA,KAAK,EAALA,KAD+B;AAE/BS,EAAAA,OAAO,EAAPA;AAF+B,CAAF,CAA9B","sourcesContent":["/**\n * External dependencies\n */\nimport { map, flowRight } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport {\n\tconservativeMapItem,\n\tifMatchingAction,\n\treplaceAction,\n\tonSubKey,\n} from '../utils';\nimport { DEFAULT_ENTITY_KEY } from '../entities';\nimport getQueryParts from './get-query-parts';\n\n/**\n * Returns a merged array of item IDs, given details of the received paginated\n * items. The array is sparse-like with `undefined` entries where holes exist.\n *\n * @param {?Array<number>} itemIds     Original item IDs (default empty array).\n * @param {number[]}       nextItemIds Item IDs to merge.\n * @param {number}         page        Page of items merged.\n * @param {number}         perPage     Number of items per page.\n *\n * @return {number[]} Merged array of item IDs.\n */\nexport function getMergedItemIds( itemIds, nextItemIds, page, perPage ) {\n\tconst receivedAllIds = page === 1 && perPage === -1;\n\tif ( receivedAllIds ) {\n\t\treturn nextItemIds;\n\t}\n\tconst nextItemIdsStartIndex = ( page - 1 ) * perPage;\n\n\t// If later page has already been received, default to the larger known\n\t// size of the existing array, else calculate as extending the existing.\n\tconst size = Math.max(\n\t\titemIds.length,\n\t\tnextItemIdsStartIndex + nextItemIds.length\n\t);\n\n\t// Preallocate array since size is known.\n\tconst mergedItemIds = new Array( size );\n\n\tfor ( let i = 0; i < size; i++ ) {\n\t\t// Preserve existing item ID except for subset of range of next items.\n\t\tconst isInNextItemsRange =\n\t\t\ti >= nextItemIdsStartIndex &&\n\t\t\ti < nextItemIdsStartIndex + nextItemIds.length;\n\n\t\tmergedItemIds[ i ] = isInNextItemsRange\n\t\t\t? nextItemIds[ i - nextItemIdsStartIndex ]\n\t\t\t: itemIds[ i ];\n\t}\n\n\treturn mergedItemIds;\n}\n\n/**\n * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\n * where identifiers are common across all queries.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nfunction items( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS':\n\t\t\tconst key = action.key || DEFAULT_ENTITY_KEY;\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...action.items.reduce( ( accumulator, value ) => {\n\t\t\t\t\tconst itemId = value[ key ];\n\t\t\t\t\taccumulator[ itemId ] = conservativeMapItem(\n\t\t\t\t\t\tstate[ itemId ],\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\t\t\t\t\treturn accumulator;\n\t\t\t\t}, {} ),\n\t\t\t};\n\t}\n\n\treturn state;\n}\n\n/**\n * Reducer tracking queries state, keyed by stable query key. Each reducer\n * query object includes `itemIds` and `requestingPageByPerPage`.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst queries = flowRight( [\n\t// Limit to matching action type so we don't attempt to replace action on\n\t// an unhandled action.\n\tifMatchingAction( ( action ) => 'query' in action ),\n\n\t// Inject query parts into action for use both in `onSubKey` and reducer.\n\treplaceAction( ( action ) => {\n\t\t// `ifMatchingAction` still passes on initialization, where state is\n\t\t// undefined and a query is not assigned. Avoid attempting to parse\n\t\t// parts. `onSubKey` will omit by lack of `stableKey`.\n\t\tif ( action.query ) {\n\t\t\treturn {\n\t\t\t\t...action,\n\t\t\t\t...getQueryParts( action.query ),\n\t\t\t};\n\t\t}\n\n\t\treturn action;\n\t} ),\n\n\t// Queries shape is shared, but keyed by query `stableKey` part. Original\n\t// reducer tracks only a single query object.\n\tonSubKey( 'stableKey' ),\n] )( ( state = null, action ) => {\n\tconst { type, page, perPage, key = DEFAULT_ENTITY_KEY } = action;\n\n\tif ( type !== 'RECEIVE_ITEMS' ) {\n\t\treturn state;\n\t}\n\n\treturn getMergedItemIds(\n\t\tstate || [],\n\t\tmap( action.items, key ),\n\t\tpage,\n\t\tperPage\n\t);\n} );\n\nexport default combineReducers( {\n\titems,\n\tqueries,\n} );\n"]}